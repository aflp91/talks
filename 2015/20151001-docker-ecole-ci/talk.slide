Docker - CI
Ecole IN2P3, 2015/10/01

Sebastien Binet
CNRS/IN2P3


* Docker origins


* The container revolution

Before 1960, cargo transport looked like:

.image _figs/transport-pre-1960.png

* MxN combinatorics: matrix from Hell

.image _figs/transport-mxn-matrix.png


* Solution: Intermodal shipping container

.image _figs/transport-mxn-solved.png


* Containers - analysis

- enables seamless shipping on roads, railways and sea (intermodal)
- standardized dimensions
- opaque box convenient for all types of goods (privacy)

.image _figs/cargo.jpg

* What is Docker?


* Application deployment

.image _figs/docker-nn-matrix.png

_Note:_ a 3rd dimension (OS/platform) could be considered

* Docker: an application container

.image _figs/docker-container-code.png

* Docker: no combinatorics no more

.image _figs/docker-nn-matrix-solved.png

* Docker

`Docker` is an open source project to pack ship and run any application as a
lightweight container: [[http://www.docker.io][docker.io]]



_Note:_ Although `docker` is primarily (ATM) Linux-oriented, it supports other
OSes (Windows+MacOSX) at the price of a thin `Linux` VM which is automatically
installed (and managed) on these systems.
See [[https://docs.docker.com/installation/][docker installation]]

* Docker

`Docker` is an open source project to pack ship and run any application as a
lightweight container: [[http://www.docker.io][docker.io]]

High-level description:

- kind of like a lightweight VM
- runs in its own process space
- has its own network interface
- can run stuff as `root`

Low-level description:

- `chroot` on steroids
- container `==` isolated process(es)
- share kernel with host
- no device emulation 

* Docker: why?

- same use cases than for VMs (for `Linux` centric workloads)
- *speed*: boots in (milli)seconds
- *footprint*: 100-1000 containers on a single machine/laptop, small disk   requirements

.image _figs/vm-lxc.png 350 600

* Docker: why?

*Efficiency*: _almost_ no overhead

- processes are isolated but run straight on the host
- `CPU` performance = *native* performance
- memory performance = a few % shaved off for (optional) accounting
- network performance = small overhead

* Docker: why?

*Efficiency*: storage friendly

- unioning filesystems
- snapshotting filesystems
- copy-on-write

* Docker: why?

- provisionning takes a few milliseconds
- ... and a few kilobytes
- creating a new container/base-image takes a few seconds

* Why are Docker containers lightweight?

.image _figs/vm-vs-containers.png 600 1000

* Separation of concerns

Tailored for the dev team:

- my code
- my framework
- my libraries
- my system dependencies
- my packaging system
- my distro
- my data

Don't care where it's running or how.

* Separation of concerns

Tailored for the ops team:

- logs
- backups
- remote access
- monitoring
- uptime

Don't care what's running in it.

* Docker: blueprint

* Docker: blueprint

_Build,_ _ship_ and _run_ any application, _anywhere_.


`Docker` uses a client/server architecture:

- the `docker` _client_ talks to
- a `docker` _daemon_ via sockets or a RESTful API.

.image _figs/architecture.svg 350 600


* Docker: basics of the system

.image _figs/docker-system.png 550 1000

* Docker: the CLI

The `docker` client ships with many a subcommand:

 $ docker help
 Usage: docker [OPTIONS] COMMAND [arg...]
        docker daemon [ --help | ... ]
        docker [ -h | --help | -v | --version ]

 A self-sufficient runtime for containers.

 [...]

 Commands:
     attach    Attach to a running container
     build     Build an image from a Dockerfile
     commit    Create a new image from a container's changes
     cp        Copy files/folders from a container to a HOSTDIR or to STDOUT
     images    List images
     import    Import the contents from a tarball to create a filesystem image
     info      Display system-wide information
 [...]

* Docker: the CLI

 $ docker version
 Client:
  Version:      1.8.1
  API version:  1.20
  Go version:   go1.4.2
  Git commit:   d12ea79
  Built:        Sat Aug 15 17:29:10 UTC 2015
  OS/Arch:      linux/amd64

 Server:
  Version:      1.8.1
  API version:  1.20
  Go version:   go1.4.2
  Git commit:   d12ea79
  Built:        Sat Aug 15 17:29:10 UTC 2015
  OS/Arch:      linux/amd64

* Hello World

Fetch a `docker` image from the `docker` registry:

 $ docker pull busybox
 Using default tag: latest
 latest: Pulling from library/busybox
 cf2616975b4a: Pull complete 
 6ce2e90b0bc7: Pull complete 
 8c2e06607696: Already exists 
 library/busybox:latest: The image you are pulling has been verified. Important: image verification is a tech preview feature and should not be relied on to provide security.
 Digest: sha256:38a203e1986cf79639cfb9b2e1d6e773de84002feea2d4eb006b52004ee8502d
 Status: Downloaded newer image for busybox:latest

 $ docker images
 REPOSITORY              TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
 busybox                 latest              8c2e06607696        4 months ago        2.43 MB

Now, run a command inside the image:

 $ docker run busybox echo "Hello World"
 Hello World


* Docker basics

- Run a container in detached mode:

 $ docker run -d busybox sh -c \
   'while true; do echo "hello"; sleep 1; done;'

- Retrieve the container id:

 $ docker ps
 CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS
 321c1aa5bcd4        busybox             "sh -c 'while true; d"   3 seconds ago       Up 2 seconds

- Attach to the running container:

 $ docker attach 321c1aa5bcd4
 hello
 hello
 [...]

- Start/stop/restart container
 
 $ docker stop 321c1aa5bcd4
 $ docker restart 321c1aa5bcd4


* Docker: public index (aka registry, aka the Hub)

`Docker` containers may be published and shared on a public registry, the `Hub`.

- It is searchable:

 $ docker search apache2
 NAME                                   STARS     OFFICIAL   AUTOMATED
 rootlogin/apache2-symfony2             7                    [OK]
 reinblau/php-apache2                   6                    [OK]
 tianon/apache2                         4                    [OK]
 [...]
 $ docker pull tianon/apache2

- Run the image and check the ports

 $ docker run -d -p 8080:80 tianon/apache2
 $ docker ps
 CONTAINER ID        IMAGE               COMMAND                  PORTS
 49614161f5b7        tianon/apache2      "apache2 -DFOREGROUND"   0.0.0.0:8080->80/tcp

The registry is also available from the browser:

- [[https://hub.docker.com][hub.docker.com]]

* Docker: creating a customized image

- run `docker` interactively:

 $ docker run -it ubuntu bash
 root@524ef6c2e4ce:/# apt-get install -y memcached
 [...]
 root@524ef6c2e4ce:/# exit
 
 $ docker commit `docker ps -q -l` binet/memcached
 4242210aba21641013b22198c7bdc00435b00850aaf9ae9cedc53ba75794891d

 $ docker run -d -p 11211 -u daemon binet/memcached memcached
 a84e18168f1473a338f9ea3473dd981bf5e3dc7e41511a1252f7bb216d875860

 $ docker ps
 CONTAINER ID        IMAGE               COMMAND                 PORTS
 a84e18168f14        binet/memcached     "memcached"             0.0.0:32768->11211/tcp
 
* Docker: creating a customized image

- interactive way is fine but not scalable
- enter `Dockerfiles`
- recipes to build an image
- start `FROM` a base image
- `RUN` commands on top of it
- easy to learn, easy to use

* Docker: Dockerfile

.code _code/dockerfile-nginx

* Docker: Dockerfile-II

- run in the directory holding that `Dockerfile`

 $ docker build -t <myname>/server .
 $ docker run -d -P <myname>/server

- retrieve the port number:

 $ docker ps
 34dc03cdbae8        binet/server         "/bin/sh -c 'nginx -g"   0.0.0.0:32770->80/tcp

or:

 $ docker inspect -f '{{.NetworkSettings.Ports}}' 34dc03cdbae8

and then:

 $ curl localhost:32770
 Hi, I am in your container!

* Docker: Dockerfile-III

*NOTE:* for Windows(TM) and MacOSX(TM) users, a thin `Linux` VM is sitting
between your machine and the container.
The container is running inside that VM so you need to replace `localhost` with
the `IP` of that VM:

 $ docker-machine ip default
 192.168.59.103

or, directly from the running container:

 $ docker inspect -f '{{.NetworkSettings.IPAddress}}' 34dc03cdbae8

and then:

 $ curl 192.168.59.103:32770
 Hi, I am in your container!
 
* docker build

- takes a snapshot after each step
- re-uses those snapshots in future builds
- doesn't re-run slow steps when it isn't necessary (cache system)

.image _figs/docker-changes-updates.png 350 800

* Docker Hub

- `docker` `push` an image to the Hub
- `docker` `pull` an image from the Hub to any machine

This brings:

- reliable deployment
- consistency

- images are self-contained, independent from host
- if it works locally, it will work on the server
- _exact_ _same_ _behavior_
- regardless of versions, distros and dependencies

* Docker-ized Hub

Going meta...

- Images on the Hub are public and shared
- Private images are possible ($$$)

But it is possible to run your own registry, on your infrastructure:

 $ docker pull registry
 $ docker run -p 5000:5000 -v <HOST_DIR>:/tmp/registry-dev registry
 
And re-start the `docker` daemon with the following extra configuration:

 -H tcp://127.0.0.1:2375 \
 -H unix:///var/run/docker.sock \
 --insecure-registry <REGISTRY_HOSTNAME>:5000

or, just qualify the image name:

 $ docker tag <some-hash-id> localhost:5000/binet/server
 $ docker push localhost:5000/binet/server


* Docker-ized Hub

- Search the private Hub

 $ docker search localhost:5000/server
 NAME           DESCRIPTION   STARS     OFFICIAL   AUTOMATED
 binet/server                 0                    
 
- Pull from the private Hub

 $ docker pull localhost:5000/binet/server
 
*NOTE:* the same remark (about the thin in-between VM) holds for Windows and
MacOSX users.
ie: replace `localhost` with the `IP` address of that `VM`.

* Docker for the developer

- manage and *control* dependencies
- if it works on my machine, it works on the cluster
- reproducibility
- small but durable recipes

Never again:

- juggle with 3 different incompatible FORTRAN compilers
- voodoo incantations to get that exotic library to link with IDL
- figure out which version of LAPACK works with that code
- ... and what obscure flag coaxed it into compiling last time

* Development workflow

- Fetch code (`git`, `mercurial`, ...)

 $ git clone git@gitlab.in2p3.fr:EcoleInfo2015/TP.git
 $ cd TP

- Edit code
- Mount code inside a `build` container
- Build+test inside that container

We'll test this workflow in the remainder of the hands-on session...

* Create a base container

- create a directory `docker-web-base` to hold the `Dockerfile` for the base container
- create the `Dockerfile` and choose your favorite `Linux` distro (say, `centos`) as a base image,
- install the needed dependencies for the web-app (`maven` on `centos`)
- run:

 $ docker build -t <myname>/web-base .


* Create a base container - solution

(see next slide)

* Create a base container - II

.code _code/base-dockerfile

* Base container for development

- One could create a new container with all the development tools (editor, completion, ...)
- But you'd need to carry over the configuration (`ssh` keys, editor, ...)

Probably easier to just mount the sources *inside* the base container:

 $ docker run -it -v `pwd`:/opt/in2p3/tp -p 8080:8080 <myname>/web-base bash
 [root@48b2c74a5004 tp]# ./bin/compile.sh 
 [root@48b2c74a5004 tp]# ./bin/run.sh     
 2015-09-10 14:13:25.467:INFO::main: Logging initialized @623ms
 2015-09-10 14:13:25.719:INFO:oejs.Server:main: jetty-9.3.z-SNAPSHOT
 2015-09-10 14:13:25.918:INFO:oejsh.ContextHandler:main: Started o.e.j.s.ServletContextHandler@4645801a{/,null,AVAILABLE}
 2015-09-10 14:13:25.933:INFO:oejs.ServerConnector:main: Started ServerConnector@62b60fbb{HTTP/1.1,[http/1.1]}{0.0.0.0:8080}
 2015-09-10 14:13:25.934:INFO:oejs.Server:main: Started @1093ms
 
In another terminal:

 $ curl localhost:8080
 <h1>Bienvenue à l'école informatique IN2P3 2015</h1>
 <a href='/analyse'>Analyse de données</a>
 session=1kdgwh0cue0efokpe5t1gcvtj

* Create the final container

Now that we know the base image "works", we'll automatize the build part as yet
another `Dockerfile`:

- create a new `Dockerfile` file (at the root of the `git` repository) based on the `web-base` image, with the correct build+run instructions
- make sure you can `docker` `build` it and tag it as `web-app`
- make sure that you can still access the web server when you run:

  $ docker run -d -p 8080:8080 localhost:5000/<myname>/web-app

_Hint:_ `ADD`

.link https://docs.docker.com/reference/builder/

* Create the final container - solutions

(see next slide)

* Create the final container - II

.code _code/webapp-dockerfile

* Create multiple versions of an image

At times, it might be very useful to test 2 versions of an application and run
them concurrently (to debug discrepancies.)

Let's do just that.

- tag the last `web-app` image as `v1`

  $ docker tag localhost:5000/<myname>/web-app localhost:5000/<myname>/web-app:v1

- modify `src/main/java/fr/in2p3/informatique/ecole2015/web/MyServlet.java` to print a different welcome message
- containerize the new version as `.../web-app:v2`

* Create multiple versions of an image - II

- run the container `v2` on port `8082`

  $ docker run -p 8082:8080 localhost:5000/<myname>/web-app:v2

- run the container `v1` on port `8080`

  $ docker run -p 8080:8080 localhost:5000/<myname>/web-app:v1

- make sure the servers on ports `8080` and `8082` display the correct welcome messages.

* Continuous Integration

Modify the `Jenkins` build to:

- build the final container
- run the tests suite
- push the result as a tagged image

* References

.link http://www.slideshare.net/jpetazzo/introduction-to-docker-december-2014-tour-de-france-bordeaux-special-edition
.link http://www.slideshare.net/dotCloud/docker-intro-november
.link https://sif.info-ufr.univ-montp2.fr/docker-talk
.link https://docs.docker.com/introduction/understanding-docker/
